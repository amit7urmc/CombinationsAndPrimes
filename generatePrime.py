class generatePrime:

    def __init__(self, fileToWrite: str="./primeListGenerated.txt")-> None:
        """
        A list of prime numbers discovered and their current steps. 
        To save computing the length in every iteration the list length is also maintained.
        fileToWrite is a file where generated prime numbers are saved.
        """
        self.primeNumbersDiscovered = [2]
        self.primeNumbersSteps = [0]
        self.runningNumber = 2
        self.primeNumbersDiscoveredListLength = 1
        self.fileToWrite = fileToWrite

    def yield_prime(self, upto_n:int)->None:
        """
        upto_n denotes how many prime numbers need to be written to the file.
        """
        with open(self.fileToWrite,"w") as fileHandle:
            fileHandle.write("primeNumbersGenerated")
            fileHandle.write("\n2")
            counter = 0
            while True:
                skipFlag = False
                self.runningNumber += 1
                for i in range(self.primeNumbersDiscoveredListLength):
                    self.primeNumbersSteps[i] += 1
                    if not self.runningNumber%self.primeNumbersDiscovered[i]:
                        skipFlag = True
                        break

                if not skipFlag:
                    self.primeNumbersDiscovered.append(self.runningNumber)
                    self.primeNumbersDiscoveredListLength += 1
                    self.primeNumbersSteps.append(0)
                    fileHandle.write(f"\n{self.runningNumber}")
                    counter += 1
                if counter >= upto_n-1:
                    break
    
    def compare_against_known_result(self, know_result_file:str="./PrimeNumbersTop1000.txt")->bool:
        """
        A known result file is taken as input. 
        Care must be taken that it has at least same number of primes as the upto_n parameter in the yield_prime method.
        """
        present_absent = None
        with open(know_result_file, "r") as knownHandle, open(self.fileToWrite,"r") as calculateddHandle:
            knownResult = knownHandle.readlines()[1:]
            calculatedResult = calculateddHandle.readlines()[1:]
            assert len(knownResult) == len(calculatedResult)
            present_absent = [True if knownResult[i]==calculatedResult[i] else False for i in range(len(knownResult))]
        if all(present_absent):
            return True
        return False



if __name__ == "__main__":
    upto_n = 1000
    full_match_str = "full_match"
    some_mismatch_str = "some_mismatch"
    primeObj = generatePrime()
    primeObj.yield_prime(upto_n)
    full_match = primeObj.compare_against_known_result()
    print(f"We tried to match first known {upto_n} primes with those generated by this program. The answer is {full_match_str if full_match else some_mismatch_str}")
